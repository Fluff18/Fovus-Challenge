{"ast":null,"code":"import { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\nconst exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {\n  if (attempt > attemptCeiling) return maxDelay;\n  const delay = minDelay * 2 ** (attempt - 1);\n  return randomInRange(minDelay, delay);\n};\nconst randomInRange = (min, max) => min + Math.random() * (max - min);\nexport const runPolling = async (_ref, input, acceptorChecks) => {\n  let {\n    minDelay,\n    maxDelay,\n    maxWaitTime,\n    abortController,\n    client,\n    abortSignal\n  } = _ref;\n  const {\n    state,\n    reason\n  } = await acceptorChecks(client, input);\n  if (state !== WaiterState.RETRY) {\n    return {\n      state,\n      reason\n    };\n  }\n  let currentAttempt = 1;\n  const waitUntil = Date.now() + maxWaitTime * 1000;\n  const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n  while (true) {\n    if (abortController?.signal?.aborted || abortSignal?.aborted) {\n      return {\n        state: WaiterState.ABORTED\n      };\n    }\n    const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n    if (Date.now() + delay * 1000 > waitUntil) {\n      return {\n        state: WaiterState.TIMEOUT\n      };\n    }\n    await sleep(delay);\n    const {\n      state,\n      reason\n    } = await acceptorChecks(client, input);\n    if (state !== WaiterState.RETRY) {\n      return {\n        state,\n        reason\n      };\n    }\n    currentAttempt += 1;\n  }\n};","map":{"version":3,"names":["sleep","WaiterState","exponentialBackoffWithJitter","minDelay","maxDelay","attemptCeiling","attempt","delay","randomInRange","min","max","Math","random","runPolling","input","acceptorChecks","maxWaitTime","abortController","client","abortSignal","state","reason","RETRY","currentAttempt","waitUntil","Date","now","log","signal","aborted","ABORTED","TIMEOUT"],"sources":["/Users/luminosity/Desktop/Fovus/node_modules/@aws-sdk/util-waiter/dist-es/poller.js"],"sourcesContent":["import { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\nconst exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {\n    if (attempt > attemptCeiling)\n        return maxDelay;\n    const delay = minDelay * 2 ** (attempt - 1);\n    return randomInRange(minDelay, delay);\n};\nconst randomInRange = (min, max) => min + Math.random() * (max - min);\nexport const runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {\n    const { state, reason } = await acceptorChecks(client, input);\n    if (state !== WaiterState.RETRY) {\n        return { state, reason };\n    }\n    let currentAttempt = 1;\n    const waitUntil = Date.now() + maxWaitTime * 1000;\n    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n    while (true) {\n        if (abortController?.signal?.aborted || abortSignal?.aborted) {\n            return { state: WaiterState.ABORTED };\n        }\n        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n        if (Date.now() + delay * 1000 > waitUntil) {\n            return { state: WaiterState.TIMEOUT };\n        }\n        await sleep(delay);\n        const { state, reason } = await acceptorChecks(client, input);\n        if (state !== WaiterState.RETRY) {\n            return { state, reason };\n        }\n        currentAttempt += 1;\n    }\n};\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,eAAe;AACrC,SAASC,WAAW,QAAQ,UAAU;AACtC,MAAMC,4BAA4B,GAAG,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,cAAc,EAAEC,OAAO,KAAK;EAClF,IAAIA,OAAO,GAAGD,cAAc,EACxB,OAAOD,QAAQ;EACnB,MAAMG,KAAK,GAAGJ,QAAQ,GAAG,CAAC,KAAKG,OAAO,GAAG,CAAC,CAAC;EAC3C,OAAOE,aAAa,CAACL,QAAQ,EAAEI,KAAK,CAAC;AACzC,CAAC;AACD,MAAMC,aAAa,GAAG,CAACC,GAAG,EAAEC,GAAG,KAAKD,GAAG,GAAGE,IAAI,CAACC,MAAM,EAAE,IAAIF,GAAG,GAAGD,GAAG,CAAC;AACrE,OAAO,MAAMI,UAAU,GAAG,aAAkFC,KAAK,EAAEC,cAAc,KAAK;EAAA,IAArG;IAAEZ,QAAQ;IAAEC,QAAQ;IAAEY,WAAW;IAAEC,eAAe;IAAEC,MAAM;IAAEC;EAAY,CAAC;EACtG,MAAM;IAAEC,KAAK;IAAEC;EAAO,CAAC,GAAG,MAAMN,cAAc,CAACG,MAAM,EAAEJ,KAAK,CAAC;EAC7D,IAAIM,KAAK,KAAKnB,WAAW,CAACqB,KAAK,EAAE;IAC7B,OAAO;MAAEF,KAAK;MAAEC;IAAO,CAAC;EAC5B;EACA,IAAIE,cAAc,GAAG,CAAC;EACtB,MAAMC,SAAS,GAAGC,IAAI,CAACC,GAAG,EAAE,GAAGV,WAAW,GAAG,IAAI;EACjD,MAAMX,cAAc,GAAGM,IAAI,CAACgB,GAAG,CAACvB,QAAQ,GAAGD,QAAQ,CAAC,GAAGQ,IAAI,CAACgB,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;EACtE,OAAO,IAAI,EAAE;IACT,IAAIV,eAAe,EAAEW,MAAM,EAAEC,OAAO,IAAIV,WAAW,EAAEU,OAAO,EAAE;MAC1D,OAAO;QAAET,KAAK,EAAEnB,WAAW,CAAC6B;MAAQ,CAAC;IACzC;IACA,MAAMvB,KAAK,GAAGL,4BAA4B,CAACC,QAAQ,EAAEC,QAAQ,EAAEC,cAAc,EAAEkB,cAAc,CAAC;IAC9F,IAAIE,IAAI,CAACC,GAAG,EAAE,GAAGnB,KAAK,GAAG,IAAI,GAAGiB,SAAS,EAAE;MACvC,OAAO;QAAEJ,KAAK,EAAEnB,WAAW,CAAC8B;MAAQ,CAAC;IACzC;IACA,MAAM/B,KAAK,CAACO,KAAK,CAAC;IAClB,MAAM;MAAEa,KAAK;MAAEC;IAAO,CAAC,GAAG,MAAMN,cAAc,CAACG,MAAM,EAAEJ,KAAK,CAAC;IAC7D,IAAIM,KAAK,KAAKnB,WAAW,CAACqB,KAAK,EAAE;MAC7B,OAAO;QAAEF,KAAK;QAAEC;MAAO,CAAC;IAC5B;IACAE,cAAc,IAAI,CAAC;EACvB;AACJ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}