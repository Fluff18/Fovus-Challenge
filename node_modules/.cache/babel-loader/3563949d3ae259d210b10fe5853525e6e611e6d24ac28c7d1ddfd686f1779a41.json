{"ast":null,"code":"var AWS = require('../core');\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n    self.fillQueue = function () {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n    self.configure(options);\n  },\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' + typeof options.tags + ' provided.');\n      }\n      this.tags = options.tags;\n    }\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' + this.minPartSize);\n    }\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n  /**\n   * @api private\n   */\n  queueSize: 4,\n  /**\n   * @api private\n   */\n  partSize: null,\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function (callback) {\n    var self = this;\n    self.failed = false;\n    self.callback = callback || function (err) {\n      if (err) throw err;\n    };\n    var runFill = true;\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.on('error', function (err) {\n          self.cleanup(err);\n        }).on('readable', function () {\n          self.fillQueue();\n        }).on('end', function () {\n          self.isDoneChunking = true;\n          self.numParts = self.totalPartNumbers;\n          self.fillQueue.call(self);\n          if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n            self.finishMultiPart();\n          }\n        });\n      }\n    }\n    if (runFill) self.fillQueue.call(self);\n  },\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: new Buffer(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function () {\n    this.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n      code: 'RequestAbortedError',\n      retryable: false\n    }));\n  },\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n    if (typeof self.body === 'string') {\n      self.body = new AWS.util.Buffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this;\n\n    // bind parameters to new service object\n    if (!self.service) {\n      self.service = new AWS.S3({\n        params: params\n      });\n    } else {\n      var config = AWS.util.copy(self.service.config);\n      self.service = new self.service.constructor.__super__(config);\n      self.service.config.params = AWS.util.merge(self.service.config.params || {}, params);\n    }\n  },\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n    try {\n      // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) {}\n\n    // try to adjust partSize if we know payload length\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n  /**\n   * @api private\n   */\n  partPos: 0,\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n  /**\n   * @api private\n   */\n  numParts: 0,\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n  /**\n   * @api private\n   */\n  activeParts: 0,\n  /**\n   * @api private\n   */\n  doneParts: 0,\n  /**\n   * @api private\n   */\n  parts: null,\n  /**\n   * @api private\n   */\n  completeInfo: null,\n  /**\n   * @api private\n   */\n  failed: false,\n  /**\n   * @api private\n   */\n  multipartReq: null,\n  /**\n   * @api private\n   */\n  partBuffers: null,\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n      self.nextChunk(buf);\n    }\n  },\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n    var buf = self.body.read(self.partSize - self.partBufferLength) || self.body.read();\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n\n      // if we have more than partSize, push the rest back on the queue\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n      self.nextChunk(pbuf);\n    }\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n    self.body.read(0);\n  },\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n    var partNumber = ++self.totalPartNumbers;\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {\n        Body: chunk\n      };\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest',\n        retryable: false\n      });\n      self.cleanup(err);\n      return null;\n    }\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n    if (!self.service.config.params.UploadId) {\n      if (!self.multipartReq) {\n        // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function (resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function (err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else {\n      // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' + AWS.util.uriEscape(this.tags[i].Value));\n    }\n    return kvPairStrings.join('&');\n  },\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n    var partInfo = {\n      ETag: null,\n      PartNumber: partNumber\n    };\n    self.completeInfo[partNumber] = partInfo;\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function (err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing',\n          retryable: false\n        });\n      }\n      if (err) return self.cleanup(err);\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n      if (self.isDoneChunking && self.doneParts === self.numParts) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function () {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return;\n\n    // clean up stream\n    if (typeof self.body.removeAllListeners === 'function' && typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    }\n\n    // cleanup multipartReq listeners\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n    AWS.util.each(self.parts, function (partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = {\n      MultipartUpload: {\n        Parts: self.completeInfo.slice(1)\n      }\n    };\n    self.service.completeMultipartUpload(completeParams, function (err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n      if (Array.isArray(self.tags)) {\n        self.service.putObjectTagging({\n          Tagging: {\n            TagSet: self.tags\n          }\n        }, function (e, d) {\n          if (e) {\n            self.callback(e);\n          } else {\n            self.callback(e, data);\n          }\n        });\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location = [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\nAWS.util.addPromises(AWS.S3.ManagedUpload);\nmodule.exports = AWS.S3.ManagedUpload;","map":{"version":3,"names":["AWS","require","byteLength","util","string","Buffer","S3","ManagedUpload","inherit","constructor","options","self","SequentialExecutor","call","body","sliceFn","callback","parts","completeInfo","fillQueue","Error","configure","partSize","minPartSize","queueSize","leavePartsOnError","tags","Array","isArray","service","bindServiceObject","params","validateBody","adjustTotalBytes","maxTotalParts","send","failed","err","runFill","fillBuffer","isNode","Stream","stream","fillStream","partBuffers","on","cleanup","isDoneChunking","numParts","totalPartNumbers","doneParts","finishMultiPart","abort","error","code","retryable","config","Body","arraySliceFn","copy","__super__","merge","totalBytes","e","newPartSize","Math","ceil","undefined","partPos","totalChunkedBytes","totalUploadedBytes","activeParts","multipartReq","partBufferLength","bodyLen","nextChunk","endPos","min","buf","read","push","length","pbuf","concat","rest","slice","isDoneSending","chunk","partNumber","Tagging","getTaggingHeader","req","putObject","_managedUpload","progress","finishSinglePart","ContentMD5","ETag","UploadId","createMultipartUpload","resp","data","queueChunks","uploadPart","kvPairStrings","i","uriEscape","Key","Value","join","partParams","ContentLength","PartNumber","partInfo","_lastUploadedBytes","message","isBrowser","removeAllListeners","resume","abortMultipartUpload","each","part","completeParams","MultipartUpload","Parts","completeMultipartUpload","Location","replace","putObjectTagging","TagSet","d","upload","request","httpReq","httpRequest","endpoint","protocol","host","path","key","Bucket","info","operation","loaded","total","emit","mixin","addPromisesToClass","PromiseDependency","prototype","promise","promisifyMethod","deletePromisesFromClass","addPromises","module","exports"],"sources":["/Users/luminosity/Desktop/Fovus/node_modules/aws-sdk/lib/s3/managed_upload.js"],"sourcesContent":["var AWS = require('../core');\nvar byteLength = AWS.util.string.byteLength;\nvar Buffer = AWS.util.Buffer;\n\n/**\n * The managed uploader allows for easy and efficient uploading of buffers,\n * blobs, or streams, using a configurable amount of concurrency to perform\n * multipart uploads where possible. This abstraction also enables uploading\n * streams of unknown size due to the use of multipart uploads.\n *\n * To construct a managed upload object, see the {constructor} function.\n *\n * ## Tracking upload progress\n *\n * The managed upload object can also track progress by attaching an\n * 'httpUploadProgress' listener to the upload manager. This event is similar\n * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress\n * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more\n * information.\n *\n * ## Handling Multipart Cleanup\n *\n * By default, this class will automatically clean up any multipart uploads\n * when an individual part upload fails. This behavior can be disabled in order\n * to manually handle failures by setting the `leavePartsOnError` configuration\n * option to `true` when initializing the upload object.\n *\n * @!event httpUploadProgress(progress)\n *   Triggered when the uploader has uploaded more data.\n *   @note The `total` property may not be set if the stream being uploaded has\n *     not yet finished chunking. In this case the `total` will be undefined\n *     until the total stream size is known.\n *   @note This event will not be emitted in Node.js 0.8.x.\n *   @param progress [map] An object containing the `loaded` and `total` bytes\n *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload\n *     size is known.\n *   @context (see AWS.Request~send)\n */\nAWS.S3.ManagedUpload = AWS.util.inherit({\n  /**\n   * Creates a managed upload object with a set of configuration options.\n   *\n   * @note A \"Body\" parameter is required to be set prior to calling {send}.\n   * @option options params [map] a map of parameters to pass to the upload\n   *   requests. The \"Body\" parameter is required to be specified either on\n   *   the service or in the params option.\n   * @note ContentMD5 should not be provided when using the managed upload object.\n   *   Instead, setting \"computeChecksums\" to true will enable automatic ContentMD5 generation\n   *   by the managed upload object.\n   * @option options queueSize [Number] (4) the size of the concurrent queue\n   *   manager to upload parts in parallel. Set to 1 for synchronous uploading\n   *   of parts. Note that the uploader will buffer at most queueSize * partSize\n   *   bytes into memory at any given time.\n   * @option options partSize [Number] (5mb) the size in bytes for each\n   *   individual part to be uploaded. Adjust the part size to ensure the number\n   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the\n   *   minimum allowed part size.\n   * @option options leavePartsOnError [Boolean] (false) whether to abort the\n   *   multipart upload if an error occurs. Set to true if you want to handle\n   *   failures manually.\n   * @option options service [AWS.S3] an optional S3 service object to use for\n   *   requests. This object might have bound parameters used by the uploader.\n   * @option options tags [Array<map>] The tags to apply to the uploaded object.\n   *   Each tag should have a `Key` and `Value` keys.\n   * @example Creating a default uploader for a stream object\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with concurrency of 1 and partSize of 10mb\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     partSize: 10 * 1024 * 1024, queueSize: 1,\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}\n   *   });\n   * @example Creating an uploader with tags\n   *   var upload = new AWS.S3.ManagedUpload({\n   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},\n   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]\n   *   });\n   * @see send\n   */\n  constructor: function ManagedUpload(options) {\n    var self = this;\n    AWS.SequentialExecutor.call(self);\n    self.body = null;\n    self.sliceFn = null;\n    self.callback = null;\n    self.parts = {};\n    self.completeInfo = [];\n    self.fillQueue = function() {\n      self.callback(new Error('Unsupported body payload ' + typeof self.body));\n    };\n\n    self.configure(options);\n  },\n\n  /**\n   * @api private\n   */\n  configure: function configure(options) {\n    options = options || {};\n    this.partSize = this.minPartSize;\n\n    if (options.queueSize) this.queueSize = options.queueSize;\n    if (options.partSize) this.partSize = options.partSize;\n    if (options.leavePartsOnError) this.leavePartsOnError = true;\n    if (options.tags) {\n      if (!Array.isArray(options.tags)) {\n        throw new Error('Tags must be specified as an array; ' +\n          typeof options.tags + ' provided.');\n      }\n      this.tags = options.tags;\n    }\n\n    if (this.partSize < this.minPartSize) {\n      throw new Error('partSize must be greater than ' +\n                      this.minPartSize);\n    }\n\n    this.service = options.service;\n    this.bindServiceObject(options.params);\n    this.validateBody();\n    this.adjustTotalBytes();\n  },\n\n  /**\n   * @api private\n   */\n  leavePartsOnError: false,\n\n  /**\n   * @api private\n   */\n  queueSize: 4,\n\n  /**\n   * @api private\n   */\n  partSize: null,\n\n  /**\n   * @readonly\n   * @return [Number] the minimum number of bytes for an individual part\n   *   upload.\n   */\n  minPartSize: 1024 * 1024 * 5,\n\n  /**\n   * @readonly\n   * @return [Number] the maximum allowed number of parts in a multipart upload.\n   */\n  maxTotalParts: 10000,\n\n  /**\n   * Initiates the managed upload for the payload.\n   *\n   * @callback callback function(err, data)\n   *   @param err [Error] an error or null if no error occurred.\n   *   @param data [map] The response data from the successful upload:\n   *     * `Location` (String) the URL of the uploaded object\n   *     * `ETag` (String) the ETag of the uploaded object\n   *     * `Bucket` (String) the bucket to which the object was uploaded\n   *     * `Key` (String) the key to which the object was uploaded\n   * @example Sending a managed upload object\n   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};\n   *   var upload = new AWS.S3.ManagedUpload({params: params});\n   *   upload.send(function(err, data) {\n   *     console.log(err, data);\n   *   });\n   */\n  send: function(callback) {\n    var self = this;\n    self.failed = false;\n    self.callback = callback || function(err) { if (err) throw err; };\n\n    var runFill = true;\n    if (self.sliceFn) {\n      self.fillQueue = self.fillBuffer;\n    } else if (AWS.util.isNode()) {\n      var Stream = AWS.util.stream.Stream;\n      if (self.body instanceof Stream) {\n        runFill = false;\n        self.fillQueue = self.fillStream;\n        self.partBuffers = [];\n        self.body.\n          on('error', function(err) { self.cleanup(err); }).\n          on('readable', function() { self.fillQueue(); }).\n          on('end', function() {\n            self.isDoneChunking = true;\n            self.numParts = self.totalPartNumbers;\n            self.fillQueue.call(self);\n\n            if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {\n              self.finishMultiPart();\n            }\n          });\n      }\n    }\n\n    if (runFill) self.fillQueue.call(self);\n  },\n\n  /**\n   * @!method  promise()\n   *   Returns a 'thenable' promise.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function(data)\n   *     Called if the promise is fulfilled.\n   *     @param data [map] The response data from the successful upload:\n   *       `Location` (String) the URL of the uploaded object\n   *       `ETag` (String) the ETag of the uploaded object\n   *       `Bucket` (String) the bucket to which the object was uploaded\n   *       `Key` (String) the key to which the object was uploaded\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] an error or null if no error occurred.\n   *   @return [Promise] A promise that represents the state of the upload request.\n   *   @example Sending an upload request using promises.\n   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});\n   *     var promise = upload.promise();\n   *     promise.then(function(data) { ... }, function(err) { ... });\n   */\n\n  /**\n   * Aborts a managed upload, including all concurrent upload requests.\n   * @note By default, calling this function will cleanup a multipart upload\n   *   if one was created. To leave the multipart upload around after aborting\n   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.\n   * @note Calling {abort} in the browser environment will not abort any requests\n   *   that are already in flight. If a multipart upload was created, any parts\n   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.\n   * @example Aborting an upload\n   *   var params = {\n   *     Bucket: 'bucket', Key: 'key',\n   *     Body: new Buffer(1024 * 1024 * 25) // 25MB payload\n   *   };\n   *   var upload = s3.upload(params);\n   *   upload.send(function (err, data) {\n   *     if (err) console.log(\"Error:\", err.code, err.message);\n   *     else console.log(data);\n   *   });\n   *\n   *   // abort request in 1 second\n   *   setTimeout(upload.abort.bind(upload), 1000);\n   */\n  abort: function() {\n    this.cleanup(AWS.util.error(new Error('Request aborted by user'), {\n      code: 'RequestAbortedError', retryable: false\n    }));\n  },\n\n  /**\n   * @api private\n   */\n  validateBody: function validateBody() {\n    var self = this;\n    self.body = self.service.config.params.Body;\n    if (typeof self.body === 'string') {\n      self.body = new AWS.util.Buffer(self.body);\n    } else if (!self.body) {\n      throw new Error('params.Body is required');\n    }\n    self.sliceFn = AWS.util.arraySliceFn(self.body);\n  },\n\n  /**\n   * @api private\n   */\n  bindServiceObject: function bindServiceObject(params) {\n    params = params || {};\n    var self = this;\n\n    // bind parameters to new service object\n    if (!self.service) {\n      self.service = new AWS.S3({params: params});\n    } else {\n      var config = AWS.util.copy(self.service.config);\n      self.service = new self.service.constructor.__super__(config);\n      self.service.config.params =\n        AWS.util.merge(self.service.config.params || {}, params);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  adjustTotalBytes: function adjustTotalBytes() {\n    var self = this;\n    try { // try to get totalBytes\n      self.totalBytes = byteLength(self.body);\n    } catch (e) { }\n\n    // try to adjust partSize if we know payload length\n    if (self.totalBytes) {\n      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);\n      if (newPartSize > self.partSize) self.partSize = newPartSize;\n    } else {\n      self.totalBytes = undefined;\n    }\n  },\n\n  /**\n   * @api private\n   */\n  isDoneChunking: false,\n\n  /**\n   * @api private\n   */\n  partPos: 0,\n\n  /**\n   * @api private\n   */\n  totalChunkedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalUploadedBytes: 0,\n\n  /**\n   * @api private\n   */\n  totalBytes: undefined,\n\n  /**\n   * @api private\n   */\n  numParts: 0,\n\n  /**\n   * @api private\n   */\n  totalPartNumbers: 0,\n\n  /**\n   * @api private\n   */\n  activeParts: 0,\n\n  /**\n   * @api private\n   */\n  doneParts: 0,\n\n  /**\n   * @api private\n   */\n  parts: null,\n\n  /**\n   * @api private\n   */\n  completeInfo: null,\n\n  /**\n   * @api private\n   */\n  failed: false,\n\n  /**\n   * @api private\n   */\n  multipartReq: null,\n\n  /**\n   * @api private\n   */\n  partBuffers: null,\n\n  /**\n   * @api private\n   */\n  partBufferLength: 0,\n\n  /**\n   * @api private\n   */\n  fillBuffer: function fillBuffer() {\n    var self = this;\n    var bodyLen = byteLength(self.body);\n\n    if (bodyLen === 0) {\n      self.isDoneChunking = true;\n      self.numParts = 1;\n      self.nextChunk(self.body);\n      return;\n    }\n\n    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {\n      var endPos = Math.min(self.partPos + self.partSize, bodyLen);\n      var buf = self.sliceFn.call(self.body, self.partPos, endPos);\n      self.partPos += self.partSize;\n\n      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {\n        self.isDoneChunking = true;\n        self.numParts = self.totalPartNumbers + 1;\n      }\n      self.nextChunk(buf);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  fillStream: function fillStream() {\n    var self = this;\n    if (self.activeParts >= self.queueSize) return;\n\n    var buf = self.body.read(self.partSize - self.partBufferLength) ||\n              self.body.read();\n    if (buf) {\n      self.partBuffers.push(buf);\n      self.partBufferLength += buf.length;\n      self.totalChunkedBytes += buf.length;\n    }\n\n    if (self.partBufferLength >= self.partSize) {\n      // if we have single buffer we avoid copyfull concat\n      var pbuf = self.partBuffers.length === 1 ?\n        self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n\n      // if we have more than partSize, push the rest back on the queue\n      if (pbuf.length > self.partSize) {\n        var rest = pbuf.slice(self.partSize);\n        self.partBuffers.push(rest);\n        self.partBufferLength += rest.length;\n        pbuf = pbuf.slice(0, self.partSize);\n      }\n\n      self.nextChunk(pbuf);\n    }\n\n    if (self.isDoneChunking && !self.isDoneSending) {\n      // if we have single buffer we avoid copyfull concat\n      pbuf = self.partBuffers.length === 1 ?\n          self.partBuffers[0] : Buffer.concat(self.partBuffers);\n      self.partBuffers = [];\n      self.partBufferLength = 0;\n      self.totalBytes = self.totalChunkedBytes;\n      self.isDoneSending = true;\n\n      if (self.numParts === 0 || pbuf.length > 0) {\n        self.numParts++;\n        self.nextChunk(pbuf);\n      }\n    }\n\n    self.body.read(0);\n  },\n\n  /**\n   * @api private\n   */\n  nextChunk: function nextChunk(chunk) {\n    var self = this;\n    if (self.failed) return null;\n\n    var partNumber = ++self.totalPartNumbers;\n    if (self.isDoneChunking && partNumber === 1) {\n      var params = {Body: chunk};\n      if (this.tags) {\n        params.Tagging = this.getTaggingHeader();\n      }\n      var req = self.service.putObject(params);\n      req._managedUpload = self;\n      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);\n      return null;\n    } else if (self.service.config.params.ContentMD5) {\n      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {\n        code: 'InvalidDigest', retryable: false\n      });\n\n      self.cleanup(err);\n      return null;\n    }\n\n    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {\n      return null; // Already uploaded this part.\n    }\n\n    self.activeParts++;\n    if (!self.service.config.params.UploadId) {\n\n      if (!self.multipartReq) { // create multipart\n        self.multipartReq = self.service.createMultipartUpload();\n        self.multipartReq.on('success', function(resp) {\n          self.service.config.params.UploadId = resp.data.UploadId;\n          self.multipartReq = null;\n        });\n        self.queueChunks(chunk, partNumber);\n        self.multipartReq.on('error', function(err) {\n          self.cleanup(err);\n        });\n        self.multipartReq.send();\n      } else {\n        self.queueChunks(chunk, partNumber);\n      }\n    } else { // multipart is created, just send\n      self.uploadPart(chunk, partNumber);\n    }\n  },\n\n  /**\n   * @api private\n   */\n  getTaggingHeader: function getTaggingHeader() {\n    var kvPairStrings = [];\n    for (var i = 0; i < this.tags.length; i++) {\n      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' +\n        AWS.util.uriEscape(this.tags[i].Value));\n    }\n\n    return kvPairStrings.join('&');\n  },\n\n  /**\n   * @api private\n   */\n  uploadPart: function uploadPart(chunk, partNumber) {\n    var self = this;\n\n    var partParams = {\n      Body: chunk,\n      ContentLength: AWS.util.string.byteLength(chunk),\n      PartNumber: partNumber\n    };\n\n    var partInfo = {ETag: null, PartNumber: partNumber};\n    self.completeInfo[partNumber] = partInfo;\n\n    var req = self.service.uploadPart(partParams);\n    self.parts[partNumber] = req;\n    req._lastUploadedBytes = 0;\n    req._managedUpload = self;\n    req.on('httpUploadProgress', self.progress);\n    req.send(function(err, data) {\n      delete self.parts[partParams.PartNumber];\n      self.activeParts--;\n\n      if (!err && (!data || !data.ETag)) {\n        var message = 'No access to ETag property on response.';\n        if (AWS.util.isBrowser()) {\n          message += ' Check CORS configuration to expose ETag header.';\n        }\n\n        err = AWS.util.error(new Error(message), {\n          code: 'ETagMissing', retryable: false\n        });\n      }\n      if (err) return self.cleanup(err);\n\n      partInfo.ETag = data.ETag;\n      self.doneParts++;\n      if (self.isDoneChunking && self.doneParts === self.numParts) {\n        self.finishMultiPart();\n      } else {\n        self.fillQueue.call(self);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  queueChunks: function queueChunks(chunk, partNumber) {\n    var self = this;\n    self.multipartReq.on('success', function() {\n      self.uploadPart(chunk, partNumber);\n    });\n  },\n\n  /**\n   * @api private\n   */\n  cleanup: function cleanup(err) {\n    var self = this;\n    if (self.failed) return;\n\n    // clean up stream\n    if (typeof self.body.removeAllListeners === 'function' &&\n        typeof self.body.resume === 'function') {\n      self.body.removeAllListeners('readable');\n      self.body.removeAllListeners('end');\n      self.body.resume();\n    }\n\n    // cleanup multipartReq listeners\n    if (self.multipartReq) {\n      self.multipartReq.removeAllListeners('success');\n      self.multipartReq.removeAllListeners('error');\n      self.multipartReq.removeAllListeners('complete');\n      delete self.multipartReq;\n    }\n\n    if (self.service.config.params.UploadId && !self.leavePartsOnError) {\n      self.service.abortMultipartUpload().send();\n    } else if (self.leavePartsOnError) {\n      self.isDoneChunking = false;\n    }\n\n    AWS.util.each(self.parts, function(partNumber, part) {\n      part.removeAllListeners('complete');\n      part.abort();\n    });\n\n    self.activeParts = 0;\n    self.partPos = 0;\n    self.numParts = 0;\n    self.totalPartNumbers = 0;\n    self.parts = {};\n    self.failed = true;\n    self.callback(err);\n  },\n\n  /**\n   * @api private\n   */\n  finishMultiPart: function finishMultiPart() {\n    var self = this;\n    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };\n    self.service.completeMultipartUpload(completeParams, function(err, data) {\n      if (err) {\n        return self.cleanup(err);\n      }\n\n      if (data && typeof data.Location === 'string') {\n        data.Location = data.Location.replace(/%2F/g, '/');\n      }\n\n      if (Array.isArray(self.tags)) {\n        self.service.putObjectTagging(\n          {Tagging: {TagSet: self.tags}},\n          function(e, d) {\n            if (e) {\n              self.callback(e);\n            } else {\n              self.callback(e, data);\n            }\n          }\n        );\n      } else {\n        self.callback(err, data);\n      }\n    });\n  },\n\n  /**\n   * @api private\n   */\n  finishSinglePart: function finishSinglePart(err, data) {\n    var upload = this.request._managedUpload;\n    var httpReq = this.request.httpRequest;\n    var endpoint = httpReq.endpoint;\n    if (err) return upload.callback(err);\n    data.Location =\n      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');\n    data.key = this.request.params.Key; // will stay undocumented\n    data.Key = this.request.params.Key;\n    data.Bucket = this.request.params.Bucket;\n    upload.callback(err, data);\n  },\n\n  /**\n   * @api private\n   */\n  progress: function progress(info) {\n    var upload = this._managedUpload;\n    if (this.operation === 'putObject') {\n      info.part = 1;\n      info.key = this.params.Key;\n    } else {\n      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;\n      this._lastUploadedBytes = info.loaded;\n      info = {\n        loaded: upload.totalUploadedBytes,\n        total: upload.totalBytes,\n        part: this.params.PartNumber,\n        key: this.params.Key\n      };\n    }\n    upload.emit('httpUploadProgress', [info]);\n  }\n});\n\nAWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);\n};\n\n/**\n * @api private\n */\nAWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.S3.ManagedUpload);\n\nmodule.exports = AWS.S3.ManagedUpload;\n"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC5B,IAAIC,UAAU,GAAGF,GAAG,CAACG,IAAI,CAACC,MAAM,CAACF,UAAU;AAC3C,IAAIG,MAAM,GAAGL,GAAG,CAACG,IAAI,CAACE,MAAM;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,GAAG,CAACM,EAAE,CAACC,aAAa,GAAGP,GAAG,CAACG,IAAI,CAACK,OAAO,CAAC;EACtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAW,EAAE,SAASF,aAAa,CAACG,OAAO,EAAE;IAC3C,IAAIC,IAAI,GAAG,IAAI;IACfX,GAAG,CAACY,kBAAkB,CAACC,IAAI,CAACF,IAAI,CAAC;IACjCA,IAAI,CAACG,IAAI,GAAG,IAAI;IAChBH,IAAI,CAACI,OAAO,GAAG,IAAI;IACnBJ,IAAI,CAACK,QAAQ,GAAG,IAAI;IACpBL,IAAI,CAACM,KAAK,GAAG,CAAC,CAAC;IACfN,IAAI,CAACO,YAAY,GAAG,EAAE;IACtBP,IAAI,CAACQ,SAAS,GAAG,YAAW;MAC1BR,IAAI,CAACK,QAAQ,CAAC,IAAII,KAAK,CAAC,2BAA2B,GAAG,OAAOT,IAAI,CAACG,IAAI,CAAC,CAAC;IAC1E,CAAC;IAEDH,IAAI,CAACU,SAAS,CAACX,OAAO,CAAC;EACzB,CAAC;EAED;AACF;AACA;EACEW,SAAS,EAAE,SAASA,SAAS,CAACX,OAAO,EAAE;IACrCA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvB,IAAI,CAACY,QAAQ,GAAG,IAAI,CAACC,WAAW;IAEhC,IAAIb,OAAO,CAACc,SAAS,EAAE,IAAI,CAACA,SAAS,GAAGd,OAAO,CAACc,SAAS;IACzD,IAAId,OAAO,CAACY,QAAQ,EAAE,IAAI,CAACA,QAAQ,GAAGZ,OAAO,CAACY,QAAQ;IACtD,IAAIZ,OAAO,CAACe,iBAAiB,EAAE,IAAI,CAACA,iBAAiB,GAAG,IAAI;IAC5D,IAAIf,OAAO,CAACgB,IAAI,EAAE;MAChB,IAAI,CAACC,KAAK,CAACC,OAAO,CAAClB,OAAO,CAACgB,IAAI,CAAC,EAAE;QAChC,MAAM,IAAIN,KAAK,CAAC,sCAAsC,GACpD,OAAOV,OAAO,CAACgB,IAAI,GAAG,YAAY,CAAC;MACvC;MACA,IAAI,CAACA,IAAI,GAAGhB,OAAO,CAACgB,IAAI;IAC1B;IAEA,IAAI,IAAI,CAACJ,QAAQ,GAAG,IAAI,CAACC,WAAW,EAAE;MACpC,MAAM,IAAIH,KAAK,CAAC,gCAAgC,GAChC,IAAI,CAACG,WAAW,CAAC;IACnC;IAEA,IAAI,CAACM,OAAO,GAAGnB,OAAO,CAACmB,OAAO;IAC9B,IAAI,CAACC,iBAAiB,CAACpB,OAAO,CAACqB,MAAM,CAAC;IACtC,IAAI,CAACC,YAAY,EAAE;IACnB,IAAI,CAACC,gBAAgB,EAAE;EACzB,CAAC;EAED;AACF;AACA;EACER,iBAAiB,EAAE,KAAK;EAExB;AACF;AACA;EACED,SAAS,EAAE,CAAC;EAEZ;AACF;AACA;EACEF,QAAQ,EAAE,IAAI;EAEd;AACF;AACA;AACA;AACA;EACEC,WAAW,EAAE,IAAI,GAAG,IAAI,GAAG,CAAC;EAE5B;AACF;AACA;AACA;EACEW,aAAa,EAAE,KAAK;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,IAAI,EAAE,UAASnB,QAAQ,EAAE;IACvB,IAAIL,IAAI,GAAG,IAAI;IACfA,IAAI,CAACyB,MAAM,GAAG,KAAK;IACnBzB,IAAI,CAACK,QAAQ,GAAGA,QAAQ,IAAI,UAASqB,GAAG,EAAE;MAAE,IAAIA,GAAG,EAAE,MAAMA,GAAG;IAAE,CAAC;IAEjE,IAAIC,OAAO,GAAG,IAAI;IAClB,IAAI3B,IAAI,CAACI,OAAO,EAAE;MAChBJ,IAAI,CAACQ,SAAS,GAAGR,IAAI,CAAC4B,UAAU;IAClC,CAAC,MAAM,IAAIvC,GAAG,CAACG,IAAI,CAACqC,MAAM,EAAE,EAAE;MAC5B,IAAIC,MAAM,GAAGzC,GAAG,CAACG,IAAI,CAACuC,MAAM,CAACD,MAAM;MACnC,IAAI9B,IAAI,CAACG,IAAI,YAAY2B,MAAM,EAAE;QAC/BH,OAAO,GAAG,KAAK;QACf3B,IAAI,CAACQ,SAAS,GAAGR,IAAI,CAACgC,UAAU;QAChChC,IAAI,CAACiC,WAAW,GAAG,EAAE;QACrBjC,IAAI,CAACG,IAAI,CACP+B,EAAE,CAAC,OAAO,EAAE,UAASR,GAAG,EAAE;UAAE1B,IAAI,CAACmC,OAAO,CAACT,GAAG,CAAC;QAAE,CAAC,CAAC,CACjDQ,EAAE,CAAC,UAAU,EAAE,YAAW;UAAElC,IAAI,CAACQ,SAAS,EAAE;QAAE,CAAC,CAAC,CAChD0B,EAAE,CAAC,KAAK,EAAE,YAAW;UACnBlC,IAAI,CAACoC,cAAc,GAAG,IAAI;UAC1BpC,IAAI,CAACqC,QAAQ,GAAGrC,IAAI,CAACsC,gBAAgB;UACrCtC,IAAI,CAACQ,SAAS,CAACN,IAAI,CAACF,IAAI,CAAC;UAEzB,IAAIA,IAAI,CAACoC,cAAc,IAAIpC,IAAI,CAACsC,gBAAgB,IAAI,CAAC,IAAItC,IAAI,CAACuC,SAAS,KAAKvC,IAAI,CAACqC,QAAQ,EAAE;YACzFrC,IAAI,CAACwC,eAAe,EAAE;UACxB;QACF,CAAC,CAAC;MACN;IACF;IAEA,IAAIb,OAAO,EAAE3B,IAAI,CAACQ,SAAS,CAACN,IAAI,CAACF,IAAI,CAAC;EACxC,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyC,KAAK,EAAE,YAAW;IAChB,IAAI,CAACN,OAAO,CAAC9C,GAAG,CAACG,IAAI,CAACkD,KAAK,CAAC,IAAIjC,KAAK,CAAC,yBAAyB,CAAC,EAAE;MAChEkC,IAAI,EAAE,qBAAqB;MAAEC,SAAS,EAAE;IAC1C,CAAC,CAAC,CAAC;EACL,CAAC;EAED;AACF;AACA;EACEvB,YAAY,EAAE,SAASA,YAAY,GAAG;IACpC,IAAIrB,IAAI,GAAG,IAAI;IACfA,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACkB,OAAO,CAAC2B,MAAM,CAACzB,MAAM,CAAC0B,IAAI;IAC3C,IAAI,OAAO9C,IAAI,CAACG,IAAI,KAAK,QAAQ,EAAE;MACjCH,IAAI,CAACG,IAAI,GAAG,IAAId,GAAG,CAACG,IAAI,CAACE,MAAM,CAACM,IAAI,CAACG,IAAI,CAAC;IAC5C,CAAC,MAAM,IAAI,CAACH,IAAI,CAACG,IAAI,EAAE;MACrB,MAAM,IAAIM,KAAK,CAAC,yBAAyB,CAAC;IAC5C;IACAT,IAAI,CAACI,OAAO,GAAGf,GAAG,CAACG,IAAI,CAACuD,YAAY,CAAC/C,IAAI,CAACG,IAAI,CAAC;EACjD,CAAC;EAED;AACF;AACA;EACEgB,iBAAiB,EAAE,SAASA,iBAAiB,CAACC,MAAM,EAAE;IACpDA,MAAM,GAAGA,MAAM,IAAI,CAAC,CAAC;IACrB,IAAIpB,IAAI,GAAG,IAAI;;IAEf;IACA,IAAI,CAACA,IAAI,CAACkB,OAAO,EAAE;MACjBlB,IAAI,CAACkB,OAAO,GAAG,IAAI7B,GAAG,CAACM,EAAE,CAAC;QAACyB,MAAM,EAAEA;MAAM,CAAC,CAAC;IAC7C,CAAC,MAAM;MACL,IAAIyB,MAAM,GAAGxD,GAAG,CAACG,IAAI,CAACwD,IAAI,CAAChD,IAAI,CAACkB,OAAO,CAAC2B,MAAM,CAAC;MAC/C7C,IAAI,CAACkB,OAAO,GAAG,IAAIlB,IAAI,CAACkB,OAAO,CAACpB,WAAW,CAACmD,SAAS,CAACJ,MAAM,CAAC;MAC7D7C,IAAI,CAACkB,OAAO,CAAC2B,MAAM,CAACzB,MAAM,GACxB/B,GAAG,CAACG,IAAI,CAAC0D,KAAK,CAAClD,IAAI,CAACkB,OAAO,CAAC2B,MAAM,CAACzB,MAAM,IAAI,CAAC,CAAC,EAAEA,MAAM,CAAC;IAC5D;EACF,CAAC;EAED;AACF;AACA;EACEE,gBAAgB,EAAE,SAASA,gBAAgB,GAAG;IAC5C,IAAItB,IAAI,GAAG,IAAI;IACf,IAAI;MAAE;MACJA,IAAI,CAACmD,UAAU,GAAG5D,UAAU,CAACS,IAAI,CAACG,IAAI,CAAC;IACzC,CAAC,CAAC,OAAOiD,CAAC,EAAE,CAAE;;IAEd;IACA,IAAIpD,IAAI,CAACmD,UAAU,EAAE;MACnB,IAAIE,WAAW,GAAGC,IAAI,CAACC,IAAI,CAACvD,IAAI,CAACmD,UAAU,GAAGnD,IAAI,CAACuB,aAAa,CAAC;MACjE,IAAI8B,WAAW,GAAGrD,IAAI,CAACW,QAAQ,EAAEX,IAAI,CAACW,QAAQ,GAAG0C,WAAW;IAC9D,CAAC,MAAM;MACLrD,IAAI,CAACmD,UAAU,GAAGK,SAAS;IAC7B;EACF,CAAC;EAED;AACF;AACA;EACEpB,cAAc,EAAE,KAAK;EAErB;AACF;AACA;EACEqB,OAAO,EAAE,CAAC;EAEV;AACF;AACA;EACEC,iBAAiB,EAAE,CAAC;EAEpB;AACF;AACA;EACEC,kBAAkB,EAAE,CAAC;EAErB;AACF;AACA;EACER,UAAU,EAAEK,SAAS;EAErB;AACF;AACA;EACEnB,QAAQ,EAAE,CAAC;EAEX;AACF;AACA;EACEC,gBAAgB,EAAE,CAAC;EAEnB;AACF;AACA;EACEsB,WAAW,EAAE,CAAC;EAEd;AACF;AACA;EACErB,SAAS,EAAE,CAAC;EAEZ;AACF;AACA;EACEjC,KAAK,EAAE,IAAI;EAEX;AACF;AACA;EACEC,YAAY,EAAE,IAAI;EAElB;AACF;AACA;EACEkB,MAAM,EAAE,KAAK;EAEb;AACF;AACA;EACEoC,YAAY,EAAE,IAAI;EAElB;AACF;AACA;EACE5B,WAAW,EAAE,IAAI;EAEjB;AACF;AACA;EACE6B,gBAAgB,EAAE,CAAC;EAEnB;AACF;AACA;EACElC,UAAU,EAAE,SAASA,UAAU,GAAG;IAChC,IAAI5B,IAAI,GAAG,IAAI;IACf,IAAI+D,OAAO,GAAGxE,UAAU,CAACS,IAAI,CAACG,IAAI,CAAC;IAEnC,IAAI4D,OAAO,KAAK,CAAC,EAAE;MACjB/D,IAAI,CAACoC,cAAc,GAAG,IAAI;MAC1BpC,IAAI,CAACqC,QAAQ,GAAG,CAAC;MACjBrC,IAAI,CAACgE,SAAS,CAAChE,IAAI,CAACG,IAAI,CAAC;MACzB;IACF;IAEA,OAAOH,IAAI,CAAC4D,WAAW,GAAG5D,IAAI,CAACa,SAAS,IAAIb,IAAI,CAACyD,OAAO,GAAGM,OAAO,EAAE;MAClE,IAAIE,MAAM,GAAGX,IAAI,CAACY,GAAG,CAAClE,IAAI,CAACyD,OAAO,GAAGzD,IAAI,CAACW,QAAQ,EAAEoD,OAAO,CAAC;MAC5D,IAAII,GAAG,GAAGnE,IAAI,CAACI,OAAO,CAACF,IAAI,CAACF,IAAI,CAACG,IAAI,EAAEH,IAAI,CAACyD,OAAO,EAAEQ,MAAM,CAAC;MAC5DjE,IAAI,CAACyD,OAAO,IAAIzD,IAAI,CAACW,QAAQ;MAE7B,IAAIpB,UAAU,CAAC4E,GAAG,CAAC,GAAGnE,IAAI,CAACW,QAAQ,IAAIX,IAAI,CAACyD,OAAO,KAAKM,OAAO,EAAE;QAC/D/D,IAAI,CAACoC,cAAc,GAAG,IAAI;QAC1BpC,IAAI,CAACqC,QAAQ,GAAGrC,IAAI,CAACsC,gBAAgB,GAAG,CAAC;MAC3C;MACAtC,IAAI,CAACgE,SAAS,CAACG,GAAG,CAAC;IACrB;EACF,CAAC;EAED;AACF;AACA;EACEnC,UAAU,EAAE,SAASA,UAAU,GAAG;IAChC,IAAIhC,IAAI,GAAG,IAAI;IACf,IAAIA,IAAI,CAAC4D,WAAW,IAAI5D,IAAI,CAACa,SAAS,EAAE;IAExC,IAAIsD,GAAG,GAAGnE,IAAI,CAACG,IAAI,CAACiE,IAAI,CAACpE,IAAI,CAACW,QAAQ,GAAGX,IAAI,CAAC8D,gBAAgB,CAAC,IACrD9D,IAAI,CAACG,IAAI,CAACiE,IAAI,EAAE;IAC1B,IAAID,GAAG,EAAE;MACPnE,IAAI,CAACiC,WAAW,CAACoC,IAAI,CAACF,GAAG,CAAC;MAC1BnE,IAAI,CAAC8D,gBAAgB,IAAIK,GAAG,CAACG,MAAM;MACnCtE,IAAI,CAAC0D,iBAAiB,IAAIS,GAAG,CAACG,MAAM;IACtC;IAEA,IAAItE,IAAI,CAAC8D,gBAAgB,IAAI9D,IAAI,CAACW,QAAQ,EAAE;MAC1C;MACA,IAAI4D,IAAI,GAAGvE,IAAI,CAACiC,WAAW,CAACqC,MAAM,KAAK,CAAC,GACtCtE,IAAI,CAACiC,WAAW,CAAC,CAAC,CAAC,GAAGvC,MAAM,CAAC8E,MAAM,CAACxE,IAAI,CAACiC,WAAW,CAAC;MACvDjC,IAAI,CAACiC,WAAW,GAAG,EAAE;MACrBjC,IAAI,CAAC8D,gBAAgB,GAAG,CAAC;;MAEzB;MACA,IAAIS,IAAI,CAACD,MAAM,GAAGtE,IAAI,CAACW,QAAQ,EAAE;QAC/B,IAAI8D,IAAI,GAAGF,IAAI,CAACG,KAAK,CAAC1E,IAAI,CAACW,QAAQ,CAAC;QACpCX,IAAI,CAACiC,WAAW,CAACoC,IAAI,CAACI,IAAI,CAAC;QAC3BzE,IAAI,CAAC8D,gBAAgB,IAAIW,IAAI,CAACH,MAAM;QACpCC,IAAI,GAAGA,IAAI,CAACG,KAAK,CAAC,CAAC,EAAE1E,IAAI,CAACW,QAAQ,CAAC;MACrC;MAEAX,IAAI,CAACgE,SAAS,CAACO,IAAI,CAAC;IACtB;IAEA,IAAIvE,IAAI,CAACoC,cAAc,IAAI,CAACpC,IAAI,CAAC2E,aAAa,EAAE;MAC9C;MACAJ,IAAI,GAAGvE,IAAI,CAACiC,WAAW,CAACqC,MAAM,KAAK,CAAC,GAChCtE,IAAI,CAACiC,WAAW,CAAC,CAAC,CAAC,GAAGvC,MAAM,CAAC8E,MAAM,CAACxE,IAAI,CAACiC,WAAW,CAAC;MACzDjC,IAAI,CAACiC,WAAW,GAAG,EAAE;MACrBjC,IAAI,CAAC8D,gBAAgB,GAAG,CAAC;MACzB9D,IAAI,CAACmD,UAAU,GAAGnD,IAAI,CAAC0D,iBAAiB;MACxC1D,IAAI,CAAC2E,aAAa,GAAG,IAAI;MAEzB,IAAI3E,IAAI,CAACqC,QAAQ,KAAK,CAAC,IAAIkC,IAAI,CAACD,MAAM,GAAG,CAAC,EAAE;QAC1CtE,IAAI,CAACqC,QAAQ,EAAE;QACfrC,IAAI,CAACgE,SAAS,CAACO,IAAI,CAAC;MACtB;IACF;IAEAvE,IAAI,CAACG,IAAI,CAACiE,IAAI,CAAC,CAAC,CAAC;EACnB,CAAC;EAED;AACF;AACA;EACEJ,SAAS,EAAE,SAASA,SAAS,CAACY,KAAK,EAAE;IACnC,IAAI5E,IAAI,GAAG,IAAI;IACf,IAAIA,IAAI,CAACyB,MAAM,EAAE,OAAO,IAAI;IAE5B,IAAIoD,UAAU,GAAG,EAAE7E,IAAI,CAACsC,gBAAgB;IACxC,IAAItC,IAAI,CAACoC,cAAc,IAAIyC,UAAU,KAAK,CAAC,EAAE;MAC3C,IAAIzD,MAAM,GAAG;QAAC0B,IAAI,EAAE8B;MAAK,CAAC;MAC1B,IAAI,IAAI,CAAC7D,IAAI,EAAE;QACbK,MAAM,CAAC0D,OAAO,GAAG,IAAI,CAACC,gBAAgB,EAAE;MAC1C;MACA,IAAIC,GAAG,GAAGhF,IAAI,CAACkB,OAAO,CAAC+D,SAAS,CAAC7D,MAAM,CAAC;MACxC4D,GAAG,CAACE,cAAc,GAAGlF,IAAI;MACzBgF,GAAG,CAAC9C,EAAE,CAAC,oBAAoB,EAAElC,IAAI,CAACmF,QAAQ,CAAC,CAAC3D,IAAI,CAACxB,IAAI,CAACoF,gBAAgB,CAAC;MACvE,OAAO,IAAI;IACb,CAAC,MAAM,IAAIpF,IAAI,CAACkB,OAAO,CAAC2B,MAAM,CAACzB,MAAM,CAACiE,UAAU,EAAE;MAChD,IAAI3D,GAAG,GAAGrC,GAAG,CAACG,IAAI,CAACkD,KAAK,CAAC,IAAIjC,KAAK,CAAC,kEAAkE,CAAC,EAAE;QACtGkC,IAAI,EAAE,eAAe;QAAEC,SAAS,EAAE;MACpC,CAAC,CAAC;MAEF5C,IAAI,CAACmC,OAAO,CAACT,GAAG,CAAC;MACjB,OAAO,IAAI;IACb;IAEA,IAAI1B,IAAI,CAACO,YAAY,CAACsE,UAAU,CAAC,IAAI7E,IAAI,CAACO,YAAY,CAACsE,UAAU,CAAC,CAACS,IAAI,KAAK,IAAI,EAAE;MAChF,OAAO,IAAI,CAAC,CAAC;IACf;;IAEAtF,IAAI,CAAC4D,WAAW,EAAE;IAClB,IAAI,CAAC5D,IAAI,CAACkB,OAAO,CAAC2B,MAAM,CAACzB,MAAM,CAACmE,QAAQ,EAAE;MAExC,IAAI,CAACvF,IAAI,CAAC6D,YAAY,EAAE;QAAE;QACxB7D,IAAI,CAAC6D,YAAY,GAAG7D,IAAI,CAACkB,OAAO,CAACsE,qBAAqB,EAAE;QACxDxF,IAAI,CAAC6D,YAAY,CAAC3B,EAAE,CAAC,SAAS,EAAE,UAASuD,IAAI,EAAE;UAC7CzF,IAAI,CAACkB,OAAO,CAAC2B,MAAM,CAACzB,MAAM,CAACmE,QAAQ,GAAGE,IAAI,CAACC,IAAI,CAACH,QAAQ;UACxDvF,IAAI,CAAC6D,YAAY,GAAG,IAAI;QAC1B,CAAC,CAAC;QACF7D,IAAI,CAAC2F,WAAW,CAACf,KAAK,EAAEC,UAAU,CAAC;QACnC7E,IAAI,CAAC6D,YAAY,CAAC3B,EAAE,CAAC,OAAO,EAAE,UAASR,GAAG,EAAE;UAC1C1B,IAAI,CAACmC,OAAO,CAACT,GAAG,CAAC;QACnB,CAAC,CAAC;QACF1B,IAAI,CAAC6D,YAAY,CAACrC,IAAI,EAAE;MAC1B,CAAC,MAAM;QACLxB,IAAI,CAAC2F,WAAW,CAACf,KAAK,EAAEC,UAAU,CAAC;MACrC;IACF,CAAC,MAAM;MAAE;MACP7E,IAAI,CAAC4F,UAAU,CAAChB,KAAK,EAAEC,UAAU,CAAC;IACpC;EACF,CAAC;EAED;AACF;AACA;EACEE,gBAAgB,EAAE,SAASA,gBAAgB,GAAG;IAC5C,IAAIc,aAAa,GAAG,EAAE;IACtB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC/E,IAAI,CAACuD,MAAM,EAAEwB,CAAC,EAAE,EAAE;MACzCD,aAAa,CAACxB,IAAI,CAAChF,GAAG,CAACG,IAAI,CAACuG,SAAS,CAAC,IAAI,CAAChF,IAAI,CAAC+E,CAAC,CAAC,CAACE,GAAG,CAAC,GAAG,GAAG,GAC3D3G,GAAG,CAACG,IAAI,CAACuG,SAAS,CAAC,IAAI,CAAChF,IAAI,CAAC+E,CAAC,CAAC,CAACG,KAAK,CAAC,CAAC;IAC3C;IAEA,OAAOJ,aAAa,CAACK,IAAI,CAAC,GAAG,CAAC;EAChC,CAAC;EAED;AACF;AACA;EACEN,UAAU,EAAE,SAASA,UAAU,CAAChB,KAAK,EAAEC,UAAU,EAAE;IACjD,IAAI7E,IAAI,GAAG,IAAI;IAEf,IAAImG,UAAU,GAAG;MACfrD,IAAI,EAAE8B,KAAK;MACXwB,aAAa,EAAE/G,GAAG,CAACG,IAAI,CAACC,MAAM,CAACF,UAAU,CAACqF,KAAK,CAAC;MAChDyB,UAAU,EAAExB;IACd,CAAC;IAED,IAAIyB,QAAQ,GAAG;MAAChB,IAAI,EAAE,IAAI;MAAEe,UAAU,EAAExB;IAAU,CAAC;IACnD7E,IAAI,CAACO,YAAY,CAACsE,UAAU,CAAC,GAAGyB,QAAQ;IAExC,IAAItB,GAAG,GAAGhF,IAAI,CAACkB,OAAO,CAAC0E,UAAU,CAACO,UAAU,CAAC;IAC7CnG,IAAI,CAACM,KAAK,CAACuE,UAAU,CAAC,GAAGG,GAAG;IAC5BA,GAAG,CAACuB,kBAAkB,GAAG,CAAC;IAC1BvB,GAAG,CAACE,cAAc,GAAGlF,IAAI;IACzBgF,GAAG,CAAC9C,EAAE,CAAC,oBAAoB,EAAElC,IAAI,CAACmF,QAAQ,CAAC;IAC3CH,GAAG,CAACxD,IAAI,CAAC,UAASE,GAAG,EAAEgE,IAAI,EAAE;MAC3B,OAAO1F,IAAI,CAACM,KAAK,CAAC6F,UAAU,CAACE,UAAU,CAAC;MACxCrG,IAAI,CAAC4D,WAAW,EAAE;MAElB,IAAI,CAAClC,GAAG,KAAK,CAACgE,IAAI,IAAI,CAACA,IAAI,CAACJ,IAAI,CAAC,EAAE;QACjC,IAAIkB,OAAO,GAAG,yCAAyC;QACvD,IAAInH,GAAG,CAACG,IAAI,CAACiH,SAAS,EAAE,EAAE;UACxBD,OAAO,IAAI,kDAAkD;QAC/D;QAEA9E,GAAG,GAAGrC,GAAG,CAACG,IAAI,CAACkD,KAAK,CAAC,IAAIjC,KAAK,CAAC+F,OAAO,CAAC,EAAE;UACvC7D,IAAI,EAAE,aAAa;UAAEC,SAAS,EAAE;QAClC,CAAC,CAAC;MACJ;MACA,IAAIlB,GAAG,EAAE,OAAO1B,IAAI,CAACmC,OAAO,CAACT,GAAG,CAAC;MAEjC4E,QAAQ,CAAChB,IAAI,GAAGI,IAAI,CAACJ,IAAI;MACzBtF,IAAI,CAACuC,SAAS,EAAE;MAChB,IAAIvC,IAAI,CAACoC,cAAc,IAAIpC,IAAI,CAACuC,SAAS,KAAKvC,IAAI,CAACqC,QAAQ,EAAE;QAC3DrC,IAAI,CAACwC,eAAe,EAAE;MACxB,CAAC,MAAM;QACLxC,IAAI,CAACQ,SAAS,CAACN,IAAI,CAACF,IAAI,CAAC;MAC3B;IACF,CAAC,CAAC;EACJ,CAAC;EAED;AACF;AACA;EACE2F,WAAW,EAAE,SAASA,WAAW,CAACf,KAAK,EAAEC,UAAU,EAAE;IACnD,IAAI7E,IAAI,GAAG,IAAI;IACfA,IAAI,CAAC6D,YAAY,CAAC3B,EAAE,CAAC,SAAS,EAAE,YAAW;MACzClC,IAAI,CAAC4F,UAAU,CAAChB,KAAK,EAAEC,UAAU,CAAC;IACpC,CAAC,CAAC;EACJ,CAAC;EAED;AACF;AACA;EACE1C,OAAO,EAAE,SAASA,OAAO,CAACT,GAAG,EAAE;IAC7B,IAAI1B,IAAI,GAAG,IAAI;IACf,IAAIA,IAAI,CAACyB,MAAM,EAAE;;IAEjB;IACA,IAAI,OAAOzB,IAAI,CAACG,IAAI,CAACuG,kBAAkB,KAAK,UAAU,IAClD,OAAO1G,IAAI,CAACG,IAAI,CAACwG,MAAM,KAAK,UAAU,EAAE;MAC1C3G,IAAI,CAACG,IAAI,CAACuG,kBAAkB,CAAC,UAAU,CAAC;MACxC1G,IAAI,CAACG,IAAI,CAACuG,kBAAkB,CAAC,KAAK,CAAC;MACnC1G,IAAI,CAACG,IAAI,CAACwG,MAAM,EAAE;IACpB;;IAEA;IACA,IAAI3G,IAAI,CAAC6D,YAAY,EAAE;MACrB7D,IAAI,CAAC6D,YAAY,CAAC6C,kBAAkB,CAAC,SAAS,CAAC;MAC/C1G,IAAI,CAAC6D,YAAY,CAAC6C,kBAAkB,CAAC,OAAO,CAAC;MAC7C1G,IAAI,CAAC6D,YAAY,CAAC6C,kBAAkB,CAAC,UAAU,CAAC;MAChD,OAAO1G,IAAI,CAAC6D,YAAY;IAC1B;IAEA,IAAI7D,IAAI,CAACkB,OAAO,CAAC2B,MAAM,CAACzB,MAAM,CAACmE,QAAQ,IAAI,CAACvF,IAAI,CAACc,iBAAiB,EAAE;MAClEd,IAAI,CAACkB,OAAO,CAAC0F,oBAAoB,EAAE,CAACpF,IAAI,EAAE;IAC5C,CAAC,MAAM,IAAIxB,IAAI,CAACc,iBAAiB,EAAE;MACjCd,IAAI,CAACoC,cAAc,GAAG,KAAK;IAC7B;IAEA/C,GAAG,CAACG,IAAI,CAACqH,IAAI,CAAC7G,IAAI,CAACM,KAAK,EAAE,UAASuE,UAAU,EAAEiC,IAAI,EAAE;MACnDA,IAAI,CAACJ,kBAAkB,CAAC,UAAU,CAAC;MACnCI,IAAI,CAACrE,KAAK,EAAE;IACd,CAAC,CAAC;IAEFzC,IAAI,CAAC4D,WAAW,GAAG,CAAC;IACpB5D,IAAI,CAACyD,OAAO,GAAG,CAAC;IAChBzD,IAAI,CAACqC,QAAQ,GAAG,CAAC;IACjBrC,IAAI,CAACsC,gBAAgB,GAAG,CAAC;IACzBtC,IAAI,CAACM,KAAK,GAAG,CAAC,CAAC;IACfN,IAAI,CAACyB,MAAM,GAAG,IAAI;IAClBzB,IAAI,CAACK,QAAQ,CAACqB,GAAG,CAAC;EACpB,CAAC;EAED;AACF;AACA;EACEc,eAAe,EAAE,SAASA,eAAe,GAAG;IAC1C,IAAIxC,IAAI,GAAG,IAAI;IACf,IAAI+G,cAAc,GAAG;MAAEC,eAAe,EAAE;QAAEC,KAAK,EAAEjH,IAAI,CAACO,YAAY,CAACmE,KAAK,CAAC,CAAC;MAAE;IAAE,CAAC;IAC/E1E,IAAI,CAACkB,OAAO,CAACgG,uBAAuB,CAACH,cAAc,EAAE,UAASrF,GAAG,EAAEgE,IAAI,EAAE;MACvE,IAAIhE,GAAG,EAAE;QACP,OAAO1B,IAAI,CAACmC,OAAO,CAACT,GAAG,CAAC;MAC1B;MAEA,IAAIgE,IAAI,IAAI,OAAOA,IAAI,CAACyB,QAAQ,KAAK,QAAQ,EAAE;QAC7CzB,IAAI,CAACyB,QAAQ,GAAGzB,IAAI,CAACyB,QAAQ,CAACC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC;MACpD;MAEA,IAAIpG,KAAK,CAACC,OAAO,CAACjB,IAAI,CAACe,IAAI,CAAC,EAAE;QAC5Bf,IAAI,CAACkB,OAAO,CAACmG,gBAAgB,CAC3B;UAACvC,OAAO,EAAE;YAACwC,MAAM,EAAEtH,IAAI,CAACe;UAAI;QAAC,CAAC,EAC9B,UAASqC,CAAC,EAAEmE,CAAC,EAAE;UACb,IAAInE,CAAC,EAAE;YACLpD,IAAI,CAACK,QAAQ,CAAC+C,CAAC,CAAC;UAClB,CAAC,MAAM;YACLpD,IAAI,CAACK,QAAQ,CAAC+C,CAAC,EAAEsC,IAAI,CAAC;UACxB;QACF,CAAC,CACF;MACH,CAAC,MAAM;QACL1F,IAAI,CAACK,QAAQ,CAACqB,GAAG,EAAEgE,IAAI,CAAC;MAC1B;IACF,CAAC,CAAC;EACJ,CAAC;EAED;AACF;AACA;EACEN,gBAAgB,EAAE,SAASA,gBAAgB,CAAC1D,GAAG,EAAEgE,IAAI,EAAE;IACrD,IAAI8B,MAAM,GAAG,IAAI,CAACC,OAAO,CAACvC,cAAc;IACxC,IAAIwC,OAAO,GAAG,IAAI,CAACD,OAAO,CAACE,WAAW;IACtC,IAAIC,QAAQ,GAAGF,OAAO,CAACE,QAAQ;IAC/B,IAAIlG,GAAG,EAAE,OAAO8F,MAAM,CAACnH,QAAQ,CAACqB,GAAG,CAAC;IACpCgE,IAAI,CAACyB,QAAQ,GACX,CAACS,QAAQ,CAACC,QAAQ,EAAE,IAAI,EAAED,QAAQ,CAACE,IAAI,EAAEJ,OAAO,CAACK,IAAI,CAAC,CAAC7B,IAAI,CAAC,EAAE,CAAC;IACjER,IAAI,CAACsC,GAAG,GAAG,IAAI,CAACP,OAAO,CAACrG,MAAM,CAAC4E,GAAG,CAAC,CAAC;IACpCN,IAAI,CAACM,GAAG,GAAG,IAAI,CAACyB,OAAO,CAACrG,MAAM,CAAC4E,GAAG;IAClCN,IAAI,CAACuC,MAAM,GAAG,IAAI,CAACR,OAAO,CAACrG,MAAM,CAAC6G,MAAM;IACxCT,MAAM,CAACnH,QAAQ,CAACqB,GAAG,EAAEgE,IAAI,CAAC;EAC5B,CAAC;EAED;AACF;AACA;EACEP,QAAQ,EAAE,SAASA,QAAQ,CAAC+C,IAAI,EAAE;IAChC,IAAIV,MAAM,GAAG,IAAI,CAACtC,cAAc;IAChC,IAAI,IAAI,CAACiD,SAAS,KAAK,WAAW,EAAE;MAClCD,IAAI,CAACpB,IAAI,GAAG,CAAC;MACboB,IAAI,CAACF,GAAG,GAAG,IAAI,CAAC5G,MAAM,CAAC4E,GAAG;IAC5B,CAAC,MAAM;MACLwB,MAAM,CAAC7D,kBAAkB,IAAIuE,IAAI,CAACE,MAAM,GAAG,IAAI,CAAC7B,kBAAkB;MAClE,IAAI,CAACA,kBAAkB,GAAG2B,IAAI,CAACE,MAAM;MACrCF,IAAI,GAAG;QACLE,MAAM,EAAEZ,MAAM,CAAC7D,kBAAkB;QACjC0E,KAAK,EAAEb,MAAM,CAACrE,UAAU;QACxB2D,IAAI,EAAE,IAAI,CAAC1F,MAAM,CAACiF,UAAU;QAC5B2B,GAAG,EAAE,IAAI,CAAC5G,MAAM,CAAC4E;MACnB,CAAC;IACH;IACAwB,MAAM,CAACc,IAAI,CAAC,oBAAoB,EAAE,CAACJ,IAAI,CAAC,CAAC;EAC3C;AACF,CAAC,CAAC;AAEF7I,GAAG,CAACG,IAAI,CAAC+I,KAAK,CAAClJ,GAAG,CAACM,EAAE,CAACC,aAAa,EAAEP,GAAG,CAACY,kBAAkB,CAAC;;AAE5D;AACA;AACA;AACAZ,GAAG,CAACM,EAAE,CAACC,aAAa,CAAC4I,kBAAkB,GAAG,SAASA,kBAAkB,CAACC,iBAAiB,EAAE;EACvF,IAAI,CAACC,SAAS,CAACC,OAAO,GAAGtJ,GAAG,CAACG,IAAI,CAACoJ,eAAe,CAAC,MAAM,EAAEH,iBAAiB,CAAC;AAC9E,CAAC;;AAED;AACA;AACA;AACApJ,GAAG,CAACM,EAAE,CAACC,aAAa,CAACiJ,uBAAuB,GAAG,SAASA,uBAAuB,GAAG;EAChF,OAAO,IAAI,CAACH,SAAS,CAACC,OAAO;AAC/B,CAAC;AAEDtJ,GAAG,CAACG,IAAI,CAACsJ,WAAW,CAACzJ,GAAG,CAACM,EAAE,CAACC,aAAa,CAAC;AAE1CmJ,MAAM,CAACC,OAAO,GAAG3J,GAAG,CAACM,EAAE,CAACC,aAAa"},"metadata":{},"sourceType":"script","externalDependencies":[]}