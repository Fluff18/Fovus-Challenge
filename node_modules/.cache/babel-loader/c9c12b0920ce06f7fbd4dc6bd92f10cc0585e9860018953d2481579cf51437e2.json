{"ast":null,"code":"// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0,\n  _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n  options = options || {};\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n  return buf ? buf : bytesToUuid(b);\n}\nmodule.exports = v1;","map":{"version":3,"names":["rng","require","bytesToUuid","_seedBytes","_nodeId","_clockseq","_lastMSecs","_lastNSecs","v1","options","buf","offset","i","b","clockseq","undefined","msecs","Date","getTime","nsecs","dt","Error","tl","tmh","node","n","module","exports"],"sources":["/Users/luminosity/Desktop/Fovus/node_modules/aws-sdk/node_modules/uuid/v1.js"],"sourcesContent":["// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n"],"mappings":"AAAA;AACA;AACA;AACA,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAW,CAAC;AAC9B,IAAIC,WAAW,GAAGD,OAAO,CAAC,mBAAmB,CAAC;;AAE9C;AACA;AACA;AACA;;AAEA;AACA,IAAIE,UAAU,GAAGH,GAAG,EAAE;;AAEtB;AACA,IAAII,OAAO,GAAG,CACZD,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,EACpBA,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAC1E;;AAED;AACA,IAAIE,SAAS,GAAG,CAACF,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,GAAGA,UAAU,CAAC,CAAC,CAAC,IAAI,MAAM;;AAE7D;AACA,IAAIG,UAAU,GAAG,CAAC;EAAEC,UAAU,GAAG,CAAC;;AAElC;AACA,SAASC,EAAE,CAACC,OAAO,EAAEC,GAAG,EAAEC,MAAM,EAAE;EAChC,IAAIC,CAAC,GAAGF,GAAG,IAAIC,MAAM,IAAI,CAAC;EAC1B,IAAIE,CAAC,GAAGH,GAAG,IAAI,EAAE;EAEjBD,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,IAAIK,QAAQ,GAAGL,OAAO,CAACK,QAAQ,KAAKC,SAAS,GAAGN,OAAO,CAACK,QAAQ,GAAGT,SAAS;;EAE5E;EACA;EACA;EACA;EACA,IAAIW,KAAK,GAAGP,OAAO,CAACO,KAAK,KAAKD,SAAS,GAAGN,OAAO,CAACO,KAAK,GAAG,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE;;EAE9E;EACA;EACA,IAAIC,KAAK,GAAGV,OAAO,CAACU,KAAK,KAAKJ,SAAS,GAAGN,OAAO,CAACU,KAAK,GAAGZ,UAAU,GAAG,CAAC;;EAExE;EACA,IAAIa,EAAE,GAAIJ,KAAK,GAAGV,UAAU,GAAI,CAACa,KAAK,GAAGZ,UAAU,IAAE,KAAK;;EAE1D;EACA,IAAIa,EAAE,GAAG,CAAC,IAAIX,OAAO,CAACK,QAAQ,KAAKC,SAAS,EAAE;IAC5CD,QAAQ,GAAGA,QAAQ,GAAG,CAAC,GAAG,MAAM;EAClC;;EAEA;EACA;EACA,IAAI,CAACM,EAAE,GAAG,CAAC,IAAIJ,KAAK,GAAGV,UAAU,KAAKG,OAAO,CAACU,KAAK,KAAKJ,SAAS,EAAE;IACjEI,KAAK,GAAG,CAAC;EACX;;EAEA;EACA,IAAIA,KAAK,IAAI,KAAK,EAAE;IAClB,MAAM,IAAIE,KAAK,CAAC,kDAAkD,CAAC;EACrE;EAEAf,UAAU,GAAGU,KAAK;EAClBT,UAAU,GAAGY,KAAK;EAClBd,SAAS,GAAGS,QAAQ;;EAEpB;EACAE,KAAK,IAAI,cAAc;;EAEvB;EACA,IAAIM,EAAE,GAAG,CAAC,CAACN,KAAK,GAAG,SAAS,IAAI,KAAK,GAAGG,KAAK,IAAI,WAAW;EAC5DN,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGU,EAAE,KAAK,EAAE,GAAG,IAAI;EACzBT,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGU,EAAE,KAAK,EAAE,GAAG,IAAI;EACzBT,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGU,EAAE,KAAK,CAAC,GAAG,IAAI;EACxBT,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGU,EAAE,GAAG,IAAI;;EAElB;EACA,IAAIC,GAAG,GAAIP,KAAK,GAAG,WAAW,GAAG,KAAK,GAAI,SAAS;EACnDH,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGW,GAAG,KAAK,CAAC,GAAG,IAAI;EACzBV,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGW,GAAG,GAAG,IAAI;;EAEnB;EACAV,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGW,GAAG,KAAK,EAAE,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC;EAClCV,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGW,GAAG,KAAK,EAAE,GAAG,IAAI;;EAE1B;EACAV,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGE,QAAQ,KAAK,CAAC,GAAG,IAAI;;EAE9B;EACAD,CAAC,CAACD,CAAC,EAAE,CAAC,GAAGE,QAAQ,GAAG,IAAI;;EAExB;EACA,IAAIU,IAAI,GAAGf,OAAO,CAACe,IAAI,IAAIpB,OAAO;EAClC,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;IAC1BZ,CAAC,CAACD,CAAC,GAAGa,CAAC,CAAC,GAAGD,IAAI,CAACC,CAAC,CAAC;EACpB;EAEA,OAAOf,GAAG,GAAGA,GAAG,GAAGR,WAAW,CAACW,CAAC,CAAC;AACnC;AAEAa,MAAM,CAACC,OAAO,GAAGnB,EAAE"},"metadata":{},"sourceType":"script","externalDependencies":[]}