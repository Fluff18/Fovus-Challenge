{"ast":null,"code":"var util = require('../util');\nvar Shape = require('../model/shape');\nfunction DomXmlParser() {}\nDomXmlParser.prototype.parse = function (xml, shape) {\n  if (xml.replace(/^\\s+/, '') === '') return {};\n  var result, error;\n  try {\n    if (window.DOMParser) {\n      try {\n        var parser = new DOMParser();\n        result = parser.parseFromString(xml, 'text/xml');\n      } catch (syntaxError) {\n        throw util.error(new Error('Parse error in document'), {\n          originalError: syntaxError,\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n      if (result.documentElement === null) {\n        throw util.error(new Error('Cannot parse empty document.'), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n      var isError = result.getElementsByTagName('parsererror')[0];\n      if (isError && (isError.parentNode === result || isError.parentNode.nodeName === 'body' || isError.parentNode.parentNode === result || isError.parentNode.parentNode.nodeName === 'body')) {\n        var errorElement = isError.getElementsByTagName('div')[0] || isError;\n        throw util.error(new Error(errorElement.textContent || 'Parser error in document'), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n    } else if (window.ActiveXObject) {\n      result = new window.ActiveXObject('Microsoft.XMLDOM');\n      result.async = false;\n      if (!result.loadXML(xml)) {\n        throw util.error(new Error('Parse error in document'), {\n          code: 'XMLParserError',\n          retryable: true\n        });\n      }\n    } else {\n      throw new Error('Cannot load XML parser');\n    }\n  } catch (e) {\n    error = e;\n  }\n  if (result && result.documentElement && !error) {\n    var data = parseXml(result.documentElement, shape);\n    var metadata = result.getElementsByTagName('ResponseMetadata')[0];\n    if (metadata) {\n      data.ResponseMetadata = parseXml(metadata, {});\n    }\n    return data;\n  } else if (error) {\n    throw util.error(error || new Error(), {\n      code: 'XMLParserError',\n      retryable: true\n    });\n  } else {\n    // empty xml document\n    return {};\n  }\n};\nfunction parseXml(xml, shape) {\n  if (!shape) shape = {};\n  switch (shape.type) {\n    case 'structure':\n      return parseStructure(xml, shape);\n    case 'map':\n      return parseMap(xml, shape);\n    case 'list':\n      return parseList(xml, shape);\n    case undefined:\n    case null:\n      return parseUnknown(xml);\n    default:\n      return parseScalar(xml, shape);\n  }\n}\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n  util.each(shape.members, function (memberName, memberShape) {\n    if (memberShape.isXmlAttribute) {\n      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n        var value = xml.attributes[memberShape.name].value;\n        data[memberName] = parseXml({\n          textContent: value\n        }, memberShape);\n      }\n    } else {\n      var xmlChild = memberShape.flattened ? xml : xml.getElementsByTagName(memberShape.name)[0];\n      if (xmlChild) {\n        data[memberName] = parseXml(xmlChild, memberShape);\n      } else if (!memberShape.flattened && memberShape.type === 'list') {\n        data[memberName] = memberShape.defaultValue;\n      }\n    }\n  });\n  return data;\n}\nfunction parseMap(xml, shape) {\n  var data = {};\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var tagName = shape.flattened ? shape.name : 'entry';\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      var key = child.getElementsByTagName(xmlKey)[0].textContent;\n      var value = child.getElementsByTagName(xmlValue)[0];\n      data[key] = parseXml(value, shape.value);\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\nfunction parseList(xml, shape) {\n  var data = [];\n  var tagName = shape.flattened ? shape.name : shape.member.name || 'member';\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      data.push(parseXml(child, shape.member));\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\nfunction parseScalar(xml, shape) {\n  if (xml.getAttribute) {\n    var encoding = xml.getAttribute('encoding');\n    if (encoding === 'base64') {\n      shape = new Shape.create({\n        type: encoding\n      });\n    }\n  }\n  var text = xml.textContent;\n  if (text === '') text = null;\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return '';\n\n  // empty object\n  if (!xml.firstElementChild) {\n    if (xml.parentNode.parentNode === null) return {};\n    if (xml.childNodes.length === 0) return '';else return xml.textContent;\n  }\n\n  // object, parse as structure\n  var shape = {\n    type: 'structure',\n    members: {}\n  };\n  var child = xml.firstElementChild;\n  while (child) {\n    var tag = child.nodeName;\n    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n      // multiple tags of the same name makes it a list\n      shape.members[tag].type = 'list';\n    } else {\n      shape.members[tag] = {\n        name: tag\n      };\n    }\n    child = child.nextElementSibling;\n  }\n  return parseStructure(xml, shape);\n}\nmodule.exports = DomXmlParser;","map":{"version":3,"names":["util","require","Shape","DomXmlParser","prototype","parse","xml","shape","replace","result","error","window","DOMParser","parser","parseFromString","syntaxError","Error","originalError","code","retryable","documentElement","isError","getElementsByTagName","parentNode","nodeName","errorElement","textContent","ActiveXObject","async","loadXML","e","data","parseXml","metadata","ResponseMetadata","type","parseStructure","parseMap","parseList","undefined","parseUnknown","parseScalar","each","members","memberName","memberShape","isXmlAttribute","Object","hasOwnProperty","call","attributes","name","value","xmlChild","flattened","defaultValue","xmlKey","key","xmlValue","tagName","child","firstElementChild","nextElementSibling","member","push","getAttribute","encoding","create","text","toType","childNodes","length","tag","module","exports"],"sources":["/Users/luminosity/Desktop/Fovus/node_modules/aws-sdk/lib/xml/browser_parser.js"],"sourcesContent":["var util = require('../util');\nvar Shape = require('../model/shape');\n\nfunction DomXmlParser() { }\n\nDomXmlParser.prototype.parse = function(xml, shape) {\n  if (xml.replace(/^\\s+/, '') === '') return {};\n\n  var result, error;\n  try {\n    if (window.DOMParser) {\n      try {\n        var parser = new DOMParser();\n        result = parser.parseFromString(xml, 'text/xml');\n      } catch (syntaxError) {\n        throw util.error(new Error('Parse error in document'),\n          {\n            originalError: syntaxError,\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n\n      if (result.documentElement === null) {\n        throw util.error(new Error('Cannot parse empty document.'),\n          {\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n\n      var isError = result.getElementsByTagName('parsererror')[0];\n      if (isError && (isError.parentNode === result ||\n          isError.parentNode.nodeName === 'body' ||\n          isError.parentNode.parentNode === result ||\n          isError.parentNode.parentNode.nodeName === 'body')) {\n        var errorElement = isError.getElementsByTagName('div')[0] || isError;\n        throw util.error(new Error(errorElement.textContent || 'Parser error in document'),\n          {\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n    } else if (window.ActiveXObject) {\n      result = new window.ActiveXObject('Microsoft.XMLDOM');\n      result.async = false;\n\n      if (!result.loadXML(xml)) {\n        throw util.error(new Error('Parse error in document'),\n          {\n            code: 'XMLParserError',\n            retryable: true\n          });\n      }\n    } else {\n      throw new Error('Cannot load XML parser');\n    }\n  } catch (e) {\n    error = e;\n  }\n\n  if (result && result.documentElement && !error) {\n    var data = parseXml(result.documentElement, shape);\n    var metadata = result.getElementsByTagName('ResponseMetadata')[0];\n    if (metadata) {\n      data.ResponseMetadata = parseXml(metadata, {});\n    }\n    return data;\n  } else if (error) {\n    throw util.error(error || new Error(), {code: 'XMLParserError', retryable: true});\n  } else { // empty xml document\n    return {};\n  }\n};\n\nfunction parseXml(xml, shape) {\n  if (!shape) shape = {};\n  switch (shape.type) {\n    case 'structure': return parseStructure(xml, shape);\n    case 'map': return parseMap(xml, shape);\n    case 'list': return parseList(xml, shape);\n    case undefined: case null: return parseUnknown(xml);\n    default: return parseScalar(xml, shape);\n  }\n}\n\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n\n  util.each(shape.members, function(memberName, memberShape) {\n    if (memberShape.isXmlAttribute) {\n      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n        var value = xml.attributes[memberShape.name].value;\n        data[memberName] = parseXml({textContent: value}, memberShape);\n      }\n    } else {\n      var xmlChild = memberShape.flattened ? xml :\n        xml.getElementsByTagName(memberShape.name)[0];\n      if (xmlChild) {\n        data[memberName] = parseXml(xmlChild, memberShape);\n      } else if (!memberShape.flattened && memberShape.type === 'list') {\n        data[memberName] = memberShape.defaultValue;\n      }\n    }\n  });\n\n  return data;\n}\n\nfunction parseMap(xml, shape) {\n  var data = {};\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var tagName = shape.flattened ? shape.name : 'entry';\n\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      var key = child.getElementsByTagName(xmlKey)[0].textContent;\n      var value = child.getElementsByTagName(xmlValue)[0];\n      data[key] = parseXml(value, shape.value);\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\n\nfunction parseList(xml, shape) {\n  var data = [];\n  var tagName = shape.flattened ? shape.name : (shape.member.name || 'member');\n\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      data.push(parseXml(child, shape.member));\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\n\nfunction parseScalar(xml, shape) {\n  if (xml.getAttribute) {\n    var encoding = xml.getAttribute('encoding');\n    if (encoding === 'base64') {\n      shape = new Shape.create({type: encoding});\n    }\n  }\n\n  var text = xml.textContent;\n  if (text === '') text = null;\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\n\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return '';\n\n  // empty object\n  if (!xml.firstElementChild) {\n    if (xml.parentNode.parentNode === null) return {};\n    if (xml.childNodes.length === 0) return '';\n    else return xml.textContent;\n  }\n\n  // object, parse as structure\n  var shape = {type: 'structure', members: {}};\n  var child = xml.firstElementChild;\n  while (child) {\n    var tag = child.nodeName;\n    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n      // multiple tags of the same name makes it a list\n      shape.members[tag].type = 'list';\n    } else {\n      shape.members[tag] = {name: tag};\n    }\n    child = child.nextElementSibling;\n  }\n  return parseStructure(xml, shape);\n}\n\nmodule.exports = DomXmlParser;\n"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,SAAS,CAAC;AAC7B,IAAIC,KAAK,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAErC,SAASE,YAAY,GAAG,CAAE;AAE1BA,YAAY,CAACC,SAAS,CAACC,KAAK,GAAG,UAASC,GAAG,EAAEC,KAAK,EAAE;EAClD,IAAID,GAAG,CAACE,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,KAAK,EAAE,EAAE,OAAO,CAAC,CAAC;EAE7C,IAAIC,MAAM,EAAEC,KAAK;EACjB,IAAI;IACF,IAAIC,MAAM,CAACC,SAAS,EAAE;MACpB,IAAI;QACF,IAAIC,MAAM,GAAG,IAAID,SAAS,EAAE;QAC5BH,MAAM,GAAGI,MAAM,CAACC,eAAe,CAACR,GAAG,EAAE,UAAU,CAAC;MAClD,CAAC,CAAC,OAAOS,WAAW,EAAE;QACpB,MAAMf,IAAI,CAACU,KAAK,CAAC,IAAIM,KAAK,CAAC,yBAAyB,CAAC,EACnD;UACEC,aAAa,EAAEF,WAAW;UAC1BG,IAAI,EAAE,gBAAgB;UACtBC,SAAS,EAAE;QACb,CAAC,CAAC;MACN;MAEA,IAAIV,MAAM,CAACW,eAAe,KAAK,IAAI,EAAE;QACnC,MAAMpB,IAAI,CAACU,KAAK,CAAC,IAAIM,KAAK,CAAC,8BAA8B,CAAC,EACxD;UACEE,IAAI,EAAE,gBAAgB;UACtBC,SAAS,EAAE;QACb,CAAC,CAAC;MACN;MAEA,IAAIE,OAAO,GAAGZ,MAAM,CAACa,oBAAoB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;MAC3D,IAAID,OAAO,KAAKA,OAAO,CAACE,UAAU,KAAKd,MAAM,IACzCY,OAAO,CAACE,UAAU,CAACC,QAAQ,KAAK,MAAM,IACtCH,OAAO,CAACE,UAAU,CAACA,UAAU,KAAKd,MAAM,IACxCY,OAAO,CAACE,UAAU,CAACA,UAAU,CAACC,QAAQ,KAAK,MAAM,CAAC,EAAE;QACtD,IAAIC,YAAY,GAAGJ,OAAO,CAACC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAID,OAAO;QACpE,MAAMrB,IAAI,CAACU,KAAK,CAAC,IAAIM,KAAK,CAACS,YAAY,CAACC,WAAW,IAAI,0BAA0B,CAAC,EAChF;UACER,IAAI,EAAE,gBAAgB;UACtBC,SAAS,EAAE;QACb,CAAC,CAAC;MACN;IACF,CAAC,MAAM,IAAIR,MAAM,CAACgB,aAAa,EAAE;MAC/BlB,MAAM,GAAG,IAAIE,MAAM,CAACgB,aAAa,CAAC,kBAAkB,CAAC;MACrDlB,MAAM,CAACmB,KAAK,GAAG,KAAK;MAEpB,IAAI,CAACnB,MAAM,CAACoB,OAAO,CAACvB,GAAG,CAAC,EAAE;QACxB,MAAMN,IAAI,CAACU,KAAK,CAAC,IAAIM,KAAK,CAAC,yBAAyB,CAAC,EACnD;UACEE,IAAI,EAAE,gBAAgB;UACtBC,SAAS,EAAE;QACb,CAAC,CAAC;MACN;IACF,CAAC,MAAM;MACL,MAAM,IAAIH,KAAK,CAAC,wBAAwB,CAAC;IAC3C;EACF,CAAC,CAAC,OAAOc,CAAC,EAAE;IACVpB,KAAK,GAAGoB,CAAC;EACX;EAEA,IAAIrB,MAAM,IAAIA,MAAM,CAACW,eAAe,IAAI,CAACV,KAAK,EAAE;IAC9C,IAAIqB,IAAI,GAAGC,QAAQ,CAACvB,MAAM,CAACW,eAAe,EAAEb,KAAK,CAAC;IAClD,IAAI0B,QAAQ,GAAGxB,MAAM,CAACa,oBAAoB,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC;IACjE,IAAIW,QAAQ,EAAE;MACZF,IAAI,CAACG,gBAAgB,GAAGF,QAAQ,CAACC,QAAQ,EAAE,CAAC,CAAC,CAAC;IAChD;IACA,OAAOF,IAAI;EACb,CAAC,MAAM,IAAIrB,KAAK,EAAE;IAChB,MAAMV,IAAI,CAACU,KAAK,CAACA,KAAK,IAAI,IAAIM,KAAK,EAAE,EAAE;MAACE,IAAI,EAAE,gBAAgB;MAAEC,SAAS,EAAE;IAAI,CAAC,CAAC;EACnF,CAAC,MAAM;IAAE;IACP,OAAO,CAAC,CAAC;EACX;AACF,CAAC;AAED,SAASa,QAAQ,CAAC1B,GAAG,EAAEC,KAAK,EAAE;EAC5B,IAAI,CAACA,KAAK,EAAEA,KAAK,GAAG,CAAC,CAAC;EACtB,QAAQA,KAAK,CAAC4B,IAAI;IAChB,KAAK,WAAW;MAAE,OAAOC,cAAc,CAAC9B,GAAG,EAAEC,KAAK,CAAC;IACnD,KAAK,KAAK;MAAE,OAAO8B,QAAQ,CAAC/B,GAAG,EAAEC,KAAK,CAAC;IACvC,KAAK,MAAM;MAAE,OAAO+B,SAAS,CAAChC,GAAG,EAAEC,KAAK,CAAC;IACzC,KAAKgC,SAAS;IAAE,KAAK,IAAI;MAAE,OAAOC,YAAY,CAAClC,GAAG,CAAC;IACnD;MAAS,OAAOmC,WAAW,CAACnC,GAAG,EAAEC,KAAK,CAAC;EAAC;AAE5C;AAEA,SAAS6B,cAAc,CAAC9B,GAAG,EAAEC,KAAK,EAAE;EAClC,IAAIwB,IAAI,GAAG,CAAC,CAAC;EACb,IAAIzB,GAAG,KAAK,IAAI,EAAE,OAAOyB,IAAI;EAE7B/B,IAAI,CAAC0C,IAAI,CAACnC,KAAK,CAACoC,OAAO,EAAE,UAASC,UAAU,EAAEC,WAAW,EAAE;IACzD,IAAIA,WAAW,CAACC,cAAc,EAAE;MAC9B,IAAIC,MAAM,CAAC3C,SAAS,CAAC4C,cAAc,CAACC,IAAI,CAAC3C,GAAG,CAAC4C,UAAU,EAAEL,WAAW,CAACM,IAAI,CAAC,EAAE;QAC1E,IAAIC,KAAK,GAAG9C,GAAG,CAAC4C,UAAU,CAACL,WAAW,CAACM,IAAI,CAAC,CAACC,KAAK;QAClDrB,IAAI,CAACa,UAAU,CAAC,GAAGZ,QAAQ,CAAC;UAACN,WAAW,EAAE0B;QAAK,CAAC,EAAEP,WAAW,CAAC;MAChE;IACF,CAAC,MAAM;MACL,IAAIQ,QAAQ,GAAGR,WAAW,CAACS,SAAS,GAAGhD,GAAG,GACxCA,GAAG,CAACgB,oBAAoB,CAACuB,WAAW,CAACM,IAAI,CAAC,CAAC,CAAC,CAAC;MAC/C,IAAIE,QAAQ,EAAE;QACZtB,IAAI,CAACa,UAAU,CAAC,GAAGZ,QAAQ,CAACqB,QAAQ,EAAER,WAAW,CAAC;MACpD,CAAC,MAAM,IAAI,CAACA,WAAW,CAACS,SAAS,IAAIT,WAAW,CAACV,IAAI,KAAK,MAAM,EAAE;QAChEJ,IAAI,CAACa,UAAU,CAAC,GAAGC,WAAW,CAACU,YAAY;MAC7C;IACF;EACF,CAAC,CAAC;EAEF,OAAOxB,IAAI;AACb;AAEA,SAASM,QAAQ,CAAC/B,GAAG,EAAEC,KAAK,EAAE;EAC5B,IAAIwB,IAAI,GAAG,CAAC,CAAC;EACb,IAAIyB,MAAM,GAAGjD,KAAK,CAACkD,GAAG,CAACN,IAAI,IAAI,KAAK;EACpC,IAAIO,QAAQ,GAAGnD,KAAK,CAAC6C,KAAK,CAACD,IAAI,IAAI,OAAO;EAC1C,IAAIQ,OAAO,GAAGpD,KAAK,CAAC+C,SAAS,GAAG/C,KAAK,CAAC4C,IAAI,GAAG,OAAO;EAEpD,IAAIS,KAAK,GAAGtD,GAAG,CAACuD,iBAAiB;EACjC,OAAOD,KAAK,EAAE;IACZ,IAAIA,KAAK,CAACpC,QAAQ,KAAKmC,OAAO,EAAE;MAC9B,IAAIF,GAAG,GAAGG,KAAK,CAACtC,oBAAoB,CAACkC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC9B,WAAW;MAC3D,IAAI0B,KAAK,GAAGQ,KAAK,CAACtC,oBAAoB,CAACoC,QAAQ,CAAC,CAAC,CAAC,CAAC;MACnD3B,IAAI,CAAC0B,GAAG,CAAC,GAAGzB,QAAQ,CAACoB,KAAK,EAAE7C,KAAK,CAAC6C,KAAK,CAAC;IAC1C;IACAQ,KAAK,GAAGA,KAAK,CAACE,kBAAkB;EAClC;EACA,OAAO/B,IAAI;AACb;AAEA,SAASO,SAAS,CAAChC,GAAG,EAAEC,KAAK,EAAE;EAC7B,IAAIwB,IAAI,GAAG,EAAE;EACb,IAAI4B,OAAO,GAAGpD,KAAK,CAAC+C,SAAS,GAAG/C,KAAK,CAAC4C,IAAI,GAAI5C,KAAK,CAACwD,MAAM,CAACZ,IAAI,IAAI,QAAS;EAE5E,IAAIS,KAAK,GAAGtD,GAAG,CAACuD,iBAAiB;EACjC,OAAOD,KAAK,EAAE;IACZ,IAAIA,KAAK,CAACpC,QAAQ,KAAKmC,OAAO,EAAE;MAC9B5B,IAAI,CAACiC,IAAI,CAAChC,QAAQ,CAAC4B,KAAK,EAAErD,KAAK,CAACwD,MAAM,CAAC,CAAC;IAC1C;IACAH,KAAK,GAAGA,KAAK,CAACE,kBAAkB;EAClC;EACA,OAAO/B,IAAI;AACb;AAEA,SAASU,WAAW,CAACnC,GAAG,EAAEC,KAAK,EAAE;EAC/B,IAAID,GAAG,CAAC2D,YAAY,EAAE;IACpB,IAAIC,QAAQ,GAAG5D,GAAG,CAAC2D,YAAY,CAAC,UAAU,CAAC;IAC3C,IAAIC,QAAQ,KAAK,QAAQ,EAAE;MACzB3D,KAAK,GAAG,IAAIL,KAAK,CAACiE,MAAM,CAAC;QAAChC,IAAI,EAAE+B;MAAQ,CAAC,CAAC;IAC5C;EACF;EAEA,IAAIE,IAAI,GAAG9D,GAAG,CAACoB,WAAW;EAC1B,IAAI0C,IAAI,KAAK,EAAE,EAAEA,IAAI,GAAG,IAAI;EAC5B,IAAI,OAAO7D,KAAK,CAAC8D,MAAM,KAAK,UAAU,EAAE;IACtC,OAAO9D,KAAK,CAAC8D,MAAM,CAACD,IAAI,CAAC;EAC3B,CAAC,MAAM;IACL,OAAOA,IAAI;EACb;AACF;AAEA,SAAS5B,YAAY,CAAClC,GAAG,EAAE;EACzB,IAAIA,GAAG,KAAKiC,SAAS,IAAIjC,GAAG,KAAK,IAAI,EAAE,OAAO,EAAE;;EAEhD;EACA,IAAI,CAACA,GAAG,CAACuD,iBAAiB,EAAE;IAC1B,IAAIvD,GAAG,CAACiB,UAAU,CAACA,UAAU,KAAK,IAAI,EAAE,OAAO,CAAC,CAAC;IACjD,IAAIjB,GAAG,CAACgE,UAAU,CAACC,MAAM,KAAK,CAAC,EAAE,OAAO,EAAE,CAAC,KACtC,OAAOjE,GAAG,CAACoB,WAAW;EAC7B;;EAEA;EACA,IAAInB,KAAK,GAAG;IAAC4B,IAAI,EAAE,WAAW;IAAEQ,OAAO,EAAE,CAAC;EAAC,CAAC;EAC5C,IAAIiB,KAAK,GAAGtD,GAAG,CAACuD,iBAAiB;EACjC,OAAOD,KAAK,EAAE;IACZ,IAAIY,GAAG,GAAGZ,KAAK,CAACpC,QAAQ;IACxB,IAAIuB,MAAM,CAAC3C,SAAS,CAAC4C,cAAc,CAACC,IAAI,CAAC1C,KAAK,CAACoC,OAAO,EAAE6B,GAAG,CAAC,EAAE;MAC5D;MACAjE,KAAK,CAACoC,OAAO,CAAC6B,GAAG,CAAC,CAACrC,IAAI,GAAG,MAAM;IAClC,CAAC,MAAM;MACL5B,KAAK,CAACoC,OAAO,CAAC6B,GAAG,CAAC,GAAG;QAACrB,IAAI,EAAEqB;MAAG,CAAC;IAClC;IACAZ,KAAK,GAAGA,KAAK,CAACE,kBAAkB;EAClC;EACA,OAAO1B,cAAc,CAAC9B,GAAG,EAAEC,KAAK,CAAC;AACnC;AAEAkE,MAAM,CAACC,OAAO,GAAGvE,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}